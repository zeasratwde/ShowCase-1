@{
    ViewBag.Title = "Bootstrap -- Collapseabel";
}
<link href="~/Content/bootStrapStyle.css" rel="stylesheet" />
<div id="SPAMain" class="pullDown">
    <article>
        <a class="btn btn-info" data-toggle="collapse" href="#collapseId1" aria-expanded="false" aria-controls="collapseExample">
            Details ...
        </a>
        <button class="btn btn-success" type="button" data-toggle="collapse" data-target="#collapseId2" aria-expanded="false" aria-controls="collapseExample">
            Confrimation ...
        </button>
        <div class="collapse" id="collapseId1">
            <div class="well">
                Your order is currently is processed. You will receive an email update, sent to the address you provided, when your order status changes.
            </div>
        </div>
        <div class="collapse" id="collapseId2">
            <div class="well">
                Thank you for your order. Your order confirmation number is 7832FG987.
            </div>
        </div>
        <div class="panel-group" id="accordion" role="tablist" aria-multiselectable="true">
            <div class="panel panel-default">
                <div class="panel-heading" role="tab" id="headingOne">
                    <h4 class="panel-title">
                        <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                            Approximate string matching
                        </a>
                    </h4>
                </div>
                <div id="collapseOne" class="panel-collapse collapse in" role="tabpanel" aria-labelledby="headingOne">
                    <div class="panel-body presentation">
                        In computer science, approximate string matching (often colloquially referred to as fuzzy string searching) is the technique of finding strings that match a pattern approximately (rather than exactly). The problem of approximate string matching is typically divided into two sub-problems:
                        finding approximate substring matches inside a given string and finding dictionary strings that match the pattern approximately.
                    </div>
                </div>
            </div>
            <div class="panel panel-default">
                <div class="panel-heading" role="tab" id="headingTwo">
                    <h4 class="panel-title">
                        <a class="collapsed" data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                            Overview
                        </a>
                    </h4>
                </div>
                <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
                    <div class="panel-body presentation">
                        The closeness of a match is measured in terms of the number of primitive operations necessary to convert the string into an exact match. This number is called the edit distance between the string and the pattern. The usual primitive operations are:[1]
                        <pre>
                        insertion: cot → coat
                        deletion: coat → cot
                        substitution: coat → cost</pre>
                        These three operations may be generalized as forms of substitution by adding a NULL character (here symbolized by *) wherever a character has been deleted or inserted:
                        <pre>
                        insertion: co*t → coat
                        deletion: coat → co*t
                        substitution: coat → cost</pre>
                        Some approximate matchers also treat transposition, in which the positions of two letters in the string are swapped, to be a primitive operation. Changing cost to cots is an example of a transposition.[2]

                        Different approximate matchers impose different constraints. Some matchers use a single global unweighted cost, that is, the total number of primitive operations necessary to convert the match to the pattern. For example, if the pattern is coil, foil differs by one substitution, coils by one insertion, oil by one deletion, and foal by two substitutions. If all operations count as a single unit of cost and the limit is set to one, foil, coils, and oil will count as matches while foal will not.

                        Other matchers specify the number of operations of each type separately, while still others set a total cost but allow different weights to be assigned to different operations. Some matchers permit separate assignments of limits and weights to individual groups in the pattern.
                    </div>
                </div>
            </div>
            <div class="panel panel-default">
                <div class="panel-heading" role="tab" id="headingThree">
                    <h4 class="panel-title">
                        <a class="collapsed" data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                            On-line versus off-line
                        </a>
                    </h4>
                </div>
                <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
                    <div class="panel-body presentation">
                        <p>Traditionally, approximate string matching algorithms are classified into two categories: on-line and off-line. With on-line algorithms the pattern can be processed before searching but the text cannot. In other words, on-line techniques do searching without an index. Early algorithms for on-line approximate matching were suggested by Wagner and Fisher[4] and by Sellers. [5] Both algorithms are based on dynamic programming but solve different problems. Sellers' algorithm searches approximately for a substring in a text while the algorithm of Wagner and Fisher calculates Levenshtein distance, being appropriate for dictionary fuzzy search only.
                        </p><p>
    On-line searching techniques have been repeatedly improved. Perhaps the most famous improvement is the bitap algorithm (also known as the shift-or and shift-and algorithm), which is very efficient for relatively short pattern strings. The Bitap algorithm is the heart of the Unix searching utility agrep. A review of on-line searching algorithms was done by G. Navarro.[6]
</p><p>
    Although very fast on-line techniques exist, their performance on large data is unacceptable. Text preprocessing or indexing makes searching dramatically faster. Today, a variety of indexing algorithms have been presented. Among them are suffix trees[7], metric trees[8] and n-gram methods.[9][10] A detailed survey of indexing techniques that allows one to find an arbitrary substring in a text is given by Navarro et al.[11]. A computational survey of dictionary methods (i.e., methods that permit finding all dictionary words that approximately match a search pattern) is given by Boytsov [12].</p>   
</div>
                </div>
            </div>
        </div>
    </article>

  
        <nav class="text-center">

            <p><a href="@Url.Action("Collapseable", "SPA")">Collapseable</a> </p>
            @*<p><a href="@Url.Action("scrollSpy", "SPA")">ScrollSpy</a></p>*@
            <p> <a href="@Url.Action("Carousel", "SPA")">Carousel</a></p>
            <p> <a href="@Url.Action("ToggableTabs", "SPA")">Togglable tabs</a></p>
            <p> <a href="@Url.Action("Modals", "SPA")">Modals</a></p>
        </nav>
   
</div>
<footer>
    <div class="text-center fontBoost">
        <br />
        <a href="@Url.Action("Collapseable", "SPA")">Collapseable</a> |
        @*<a href="@Url.Action("scrollSpy", "SPA")">ScrollSpy</a> |*@
        <a href="@Url.Action("Carousel", "SPA")">Carousel</a> |
        <a href="@Url.Action("ToggableTabs", "SPA")">Togglable tabs</a> |
        <a href="@Url.Action("Modals", "SPA")">Modals</a>
        <p>&copy; @DateTime.Now.Year - Asrat Zewde</p>
    </div>
</footer>
